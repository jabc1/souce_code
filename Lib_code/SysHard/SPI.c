/***************************Copyright BestFu 2014-05-14*************************
文	件：    SPI.c
说	明：    SPI外设寄存器配置
编	译：    Keil uVision4 V4.54.0.0
版	本：    v1.0
编	写：    Unarty
日	期：    2013-08-24
修　改：	暂无
*******************************************************************************/
#include "spi.h"
#include "BF_type.h"

/*******************************************************************************
** 函数名称:    SPI2_Init
** 功能描述:    SPI口初始化代码
** 输　入:      无
** 返  回:      无
** 注  意:      配置成主机模式 ,对SPI2属于APB1的外设.时钟频率最大为36M.
*******************************************************************************/
void SPI2_Init(void)
{
	RCC->APB1RSTR |= 1<<14;
	RCC->APB1RSTR &= ~(1<<14);

	RCC->APB2ENR |= 1<<3;  	    //PORTB时钟使能 	 
	RCC->APB1ENR |= 1<<14;   	//SPI2时钟使能 

	GPIOB->CRH   &= 0X000FFFFF; 
	GPIOB->CRH   |= 0XBBB00000;	//PB13/14/15复用 	    
	GPIOB->ODR   |= 0X7<<13;   	//PB13/14/15上拉
	 
	SPI2->CR1    |= 0<<10;		//全双工模式	
	SPI2->CR1    |= 1<<9; 		//软件nss管理
	SPI2->CR1    |= 1<<8;  

	SPI2->CR1    |= 1<<2; 		//SPI主机
	SPI2->CR1    |= 0<<11;		//8bit数据格式	
	//SPI2->CR1|=1<<1; 		    //空闲模式下SCK为1 CPOL=1
	//SPI2->CR1|=1<<0; 		    //数据采样从第二个时间边沿开始,CPHA=1  
	//对SPI2属于APB1的外设.时钟频率最大为36M.
	SPI2->CR1    |= 3<<3; 		//Fsck=Fpclk1/256
	SPI2->CR1    |= 0<<7; 		//MSBfirst   
	SPI2->CR1    |= 1<<6; 		//SPI设备使能
	
	SPI2_ReadWriteByte(0xff);   //启动传输		 
}

/*******************************************************************************
** 函数名称:    SPI2_SetSpeed
** 功能描述:    SPI2速度设置函数
** 输　入:      SpeedSet: 0~7
** 返  回:      无
** 注  意:      SPI速度=fAPB1/(1<<(SpeedSet+1))  /APB1时钟一般为36Mhz
*******************************************************************************/
void SPI2_SetSpeed(u8 SpeedSet)
{
	SpeedSet  &= 0X07;			//限制范围
	SPI2->CR1 &= 0XFFC7; 
	SPI2->CR1 |= SpeedSet<<3;	//设置SPI2速度  
	SPI2->CR1 |= 1<<6; 		    //SPI设备使能	  
}

/*******************************************************************************
** 函数名称:    SPI2_ReadWriteByte
** 功能描述:    SPI2 读写一个字节
** 输　入:      无
** 返  回:      SPI接收缓冲区内容     
*******************************************************************************/
u8 SPI2_ReadWriteByte(u8 TxData)
{		
	u16 retry=0;				 
	while (!(SPI2->SR&(1<<1)))		//等待发送区空	
	{
		if (retry++>=0XFFFE)
		{
			return 0; 	//超时退出
		}
	}
	SPI2->DR = TxData;	 	  		//发送一个byte 
	retry = 0;
	while (!(SPI2->SR&(1<<0))) 		//等待接收完一个byte  
	{
		if (retry++>=0XFFFE)
		{
			return 0;	//超时退出
		}
	}

	return SPI2->DR;   //返回接收缓冲区内容 
}


/**************************Copyright BestFu 2014-05-14*************************/

